# Vault Database Dynamic/Static Creds Example

## Описание:

Это простейший пример, реализованный на Python, который забирает учетные данные из Vault и подставляет их в момент подключения к БД PostgreSQL. Поддерживает как динамические, так и статические секреты Vault в рамках подсистемы секретов Database. Но самое главное то, что, поскольку скрипт изначально крутится в бесконечном цикле, мы можем явным образом увидеть процесс ротации учетных данных в Vault, когда истекает срок жизни пароля или он был изменен вручную. И при этом приложение заново осуществялет запрос к Vault, получает вновь валидные данные и снова подключается к БД. Так что это сугубо ознакомительный пример с целью более детально понять, как приложение будет работать в сочетании с такими инструментами как Vault и PostgreSQL. Пример не предназначен для реального использования. И в целом был создан в рамках написания статьи, состаящей из двух частей ([1](https://telegra.ph/Integraciya-HashiCorp-Vault-s-BD-na-primere-PostgreSQL-CHast-5-06-13) и [2](https://telegra.ph/Integraciya-HashiCorp-Vault-s-BD-na-primere-PostgreSQL-CHast-52-06-29)), в которой подробно рассказывается о всевозможных настройках по интеграции между двумя вышеупомянутыми сервисами.

## Подготовка к запуску:

Минимальный набор действий, необходимый для запуска примера:

```
git clone https://github.com/exitfound/vault-database-creds-example.git
pip3 install -r requirements.txt
python3 example.py
```

Перед запуском вам также нужно будет изменить содержимое файла `.env`. Укажите через HTTP / HTTPS адрес своего сервера Vault (вместе с портом, если не используете TLS) и токен, у которого есть доступ к подсистеме секретов Database, и который может получить учетные данные по пути `<database>/<creds_or_static-creds>/<name_of_role>`. Ниже представлен соответствующий пример файла `.env`:

```
VAULT_TOKEN = "Your_vault_token_there"
VAULT_ADDR = "http://vault.your.domain:8200"
DB_PORT = "5432"
DB_HOST = "localhost"
DB_NAME = "postgres"
```

## Работа со скриптом:

Как уже было отмечено ранее запуск осуществляется следующим образом:

```
python3 example.py
```

После этого вам будет предложено ввести три значения:

- Путь к подсистеме секретов базы данных (Secret Engine от Vault). По умолчанию это database;

- Тип учетных данных (Dynamic или Static Creds), поскольку скрипт поддерживает оба варианта. По умолчанию это creds, то бишь динамический вариант;

- Непосредственно само имя роли, которая была создана во время настройки Vault для интеграции с БД Postgresql. По умолчанию это postgresql-role;

По сути это аналог двух консольных команд в Vault:

```
vault read database/creds/postgresql-role - для получения динамических учетных данных;
```

```
vault read database/static-creds/postgresql-role - для получения статических учетных данных;
```

Примечание: Важно понимать, что database как и postgresql-role, это просто имена, и в вашем случае путь может отличаться.

После чего, в случае валидности всех введенных данных, а также того, что указано в файле `.env`, скрипт начнет свою работу в бесконечном цикле. В нём же будет предоставлена базовая информация на предмет того, какой сейчас пользователь и пароль от Vault используются. Если вы желаете прервать работу скрипта, нажмите следующее сочетание клавиш:

```
Ctrl + C
```

Если вы хотите в явном виде увидеть как приложение потеряет доступ к базе из-за того, что пароль протух, а потом вновь обратится к Vault за обновленным вариантом, и снова подключится к базе, вы можете выставить крайне низкий TTL при настройке Vault и просто подождать или использовать следующие команды в соседнем окне во время работы скрипта:

```
vault lease revoke -prefix database/creds/postgresql-role - условный rotate для динамических учетных данных;
```

```
vault write -f database/rotate-role/postgresql-role - rotate для статических учетных данных;
```

Подробнее обо всех командах по работе с динамическими / статическими учетными данными в рамках работы с БД можно найти в статье по ссылкам выше.

## Важное замечание:

В скрипте я постарался обработать хотя бы какие-то базовые ошибки в виде исключений, которые могут возникнуть. Однако в случае с psycopg возникла проблема в том плане, что в их официальной документации нет адекватной обработки на тот случай, когда у нас endpoint БД недоступен. Из-за этого (как костыль) пришлось ошибку конвертировать в строку и по ней уже что-то определять. Поэтому если вы укажите базу, у которой нет связи с Vault, но которая при этом является доступной, цикл будет отрабатывать одновременно с сообщением об ошибке, и с тем, что данные от Vault успешно были обновлены. Этот казус я устранить не смог. Причем схожую проблему я находил и у других людей. Не то чтобы это критично и при валидности узлов это никак не повлияет на демонстрацию как такого, но предупредить вас мне всё же хотелось бы. Такие дела.
